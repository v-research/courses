\section{Sintassi e semantica informale}

Una firma $\Sigma$ consiste in un insieme finito di funzioni simboliche, come $f$, encryption e concatenazione, ciascuna con un'arietà. Una funzione simbolica con arietà 0 è un simbolo costante.
Data una firma $Sigma$, un insieme infinito di nomi, e un insieme infinito di variabili, l'insieme di termini è definito dalla grammatica:


    \begin{table}[h!]
        \begin{tabular}{ll}
            
            $L, M, N, T, U, V ::=$ & $termini$\\
            \quad$a, b, c, \dots , k, \dots , m, n, \dots , s$ & $nomi$\\
            \quad$x, y, z$ & $variabili$\\
            \quad$f(M_1, \dots , M_l)$ & $applicazione \: di \: funzione$
           
        \end{tabular}
    \end{table}

    \newpage
    \noindent dove $f$ fa parte di $\Sigma$ e $l$ corrisponde all'arietà di $f$.
    
    
    La grammatica per i processi è simile a quella del pi calculus, ma qui i messaggi possono contenere termini (piuttosto che solo nomi) e i nomi necessari non sono solo i nomi dei canali:
    \begin{table}[h!]
        \begin{tabular}{ll}
            
            $P, Q, R ::=$ & $processi$\\
            \quad$0$ & $processo \: vuoto$\\
            \quad$P|Q$ & $composizione \: parallela$\\
            \quad$!P$ & $replicazione$\\
            \quad$\nu n.P$ & $limitazione \: del \: nome$\\
            \quad$if \: M = N \: then \: P \: else \: Q$ & $condizione$\\
            \quad$N(x).P$ & $messaggio \: in \: input$\\
            \quad$\bar{N}(M).P$ & $messaggio \: in \: output$

           
        \end{tabular}
    \end{table}

Il processo vuoto 0 non fa nulla, $P|Q$ è la composizione parallela di $P$ e $Q$; la replicazione $!P$ si comporta come un numero infinito di copie di $P$ in esecuzione in parallelo.\\ 
Il processo $\nu n.P$ crea un nuovo nome privato n si comporta come P.\\
Il costrutto condizionale $if \: M = N \: then \: P \: else \: Q$ è standard e $M=N$ rappresenta l'uguaglianza, non l'identità.\\
Infine, $N(x).P$ significa che il processo $P$ è pronto per essere eseguito utilizzando il messaggio $x$ che riceve in input dal canale $N$, mentre $\bar{N}(M).P$ significa che il processo $P$ è pronto a trasmettere il messaggio $M$ sul canale $N$.

\bigskip
CI SAREBBE LA GRAMMATICA DELL'ESTENSIONE DEI PROCESSI, MA TUTTO QUESTO SERVE NEL MIO REPORT?

% Inoltre, estendiamo i processi con sostituzioni attive:

% %grammatica 3

% Scriviamo {M/x} per la sostituzione che sostituisce la variabile x con il termine M. Considerato come un processo, {M/x} è come let x = M in . . . ed è altrettanto utile. Tuttavia, a differenza di
% una definizione "let", {M/x} galleggia e si applica a qualsiasi processo che entra in contatto con esso.
% Per controllare questo contatto, possiamo aggiungere una restrizione: νx. ({M/x} | P) corrisponde esattamente a
% let x = M in P. La sostituzione {M/x} compare tipicamente quando il termine M è stato inviato
% per l'ambiente, ma l'ambiente non può avere i nomi atomici che appaiono in
% M; la variabile x è solo un modo per riferirsi a M in questa situazione. Anche se la sostituzione
% {M/x} riguarda una sola variabile, possiamo costruire sostituzioni più grandi per composizione parallela,
% e può scrivere
% {
% M1/x1
% , . . . ,
% Ml/xl
% } per {
% M1/x1
% } | | {Ml/xl
% }
% Scriviamo σ, {M/x}, {Mf/Xe} per le sostituzioni, xσ per l'immagine di x da σ, e T σ per la
% risultato dell'applicazione di σ alle variabili libere di T. Identifichiamo la sostituzione vuota e la
% processo nullo 0.
% Come al solito, nomi e variabili hanno scopi, che sono delimitati da restrizioni e
% per input. Scriviamo fv(A) e fn(A) per gli insiemi di variabili libere e nomi liberi di A,
% rispettivamente. Questi insiemi sono definiti induttivamente, come descritto nella figura 1.